package Lab1;

import com.dropbox.core.DbxAppInfo;
import com.dropbox.core.DbxClient;
import com.dropbox.core.DbxEntry;
import com.dropbox.core.DbxException;
import com.dropbox.core.DbxRequestConfig;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import static java.sql.Types.NULL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Queue;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.yaml.snakeyaml.Yaml;

public class MessagePasser
{ 
    LinkedList<TimeStampedMessage> delayed_send_queue=new LinkedList<TimeStampedMessage>();
    LinkedList<TimeStampedMessage> delayed_received_queue=new LinkedList<TimeStampedMessage>();
    LinkedList<TimeStampedMessage> received_queue=new LinkedList<TimeStampedMessage>();
    Map<String,Socket> sendingMap;
    ArrayList<TimeStampedMessage> send_delayed_queue;
    String conf_file,local_name;
    int port_number;
    static int ISN;
    List<Map<String, Object>> conf;
    List<Map<String, Object>> sendRules;
    List<Map<String, Object>> recvRules;
    Object lock = new Object();
    ClockService clock;
    String clock_type;
    int our_process_number;
    
    public MessagePasser(String configuration_filename, String local_name, String clock_type) 
            throws FileNotFoundException
    {
        int number_of_names = 0;
        sendingMap = new HashMap<String,Socket>();
        ISN = 0;
        this.conf_file=configuration_filename;
        this.local_name=local_name;
        conf_file = conf_file;
        InputStream input = new FileInputStream(new File(conf_file));
        Yaml yaml = new Yaml();
        Map map = (Map) yaml.load(input);
        conf = (List<Map<String, Object>>) map.get("configuration");
        sendRules = (List<Map<String, Object>>) map.get("sendRules");
        recvRules = (List<Map<String, Object>>) map.get("receiveRules");
        for (Map<String, Object> config:conf) 
        {
            if (config.get("name").equals(this.local_name)) 
            {
                this.our_process_number = number_of_names;
                port_number = (Integer) config.get("port");
            }
            number_of_names ++;
        }
        Socket_Listener sl = new Socket_Listener(port_number,this);
        Thread worker = new Thread(sl);
        worker.start();
        //Thread t=new Thread(this);
        //t.start();
        this.clock_type = clock_type;
        if (clock_type.equals("Logical")) clock = new LogicalClock();
        if (clock_type.equals("Vector")) clock = new VectorClock(number_of_names, our_process_number);
    }
    void send(TimeStampedMessage message)
    {
        try
        {
            //Code to check rules and send data
            //Use settors of Message class
            message.set_source(local_name);           
            String src = local_name, dest = message.destination, 
                    kind = message.kind;
            message.set_seqNum(ISN++);
            int seqNum=message.seqNum;
            message.set_duplicate(false);
            String action = "send";
            Socket s;
            //System.out.println("About to create socket!");
            if(!sendingMap.containsKey(message.destination))
            {
                String IP = "";
                int port_no = -1;
                for (Map<String, Object> config:conf) 
                {
                        if (config.get("name").equals(message.destination)) 
                        {
                                IP = (String) config.get("ip");
                                port_no = (Integer) config.get("port");
                                break;
                        }
                }
                if(port_no == -1)
                {
                    System.out.println("IP of destination not reachable");
                    return;
                }
                s=new Socket(IP,port_no);
                sendingMap.put(message.destination, s);
            }
            else
            {
                s=sendingMap.get(message.destination);
            }
            //System.out.println("Socket s initialized");
            ObjectOutputStream oos;     
            /* check the rules for sending/recving */
            for (Map<String, Object> rule:sendRules) 
            {
                if (rule.containsKey("src") && !rule.get("src").equals(src) ||
                    rule.containsKey("kind") && !rule.get("kind").equals(kind)||
                    rule.containsKey("dest") && !rule.get("dest").equals(dest)||
                    rule.containsKey("seqNum") && 
                        !rule.get("seqNum").equals(seqNum))
                        continue;
                action = (String) rule.get("action");
                break;
            }       
            //System.out.println(action);
            try
            {
                if(action.equals("drop"))
                {
                    //System.out.println("Message dropped!");
                }
                    
                else if(action.equals("delay"))
                {
                    //System.out.println("Message delayed!");
                    delayed_send_queue.addLast(message);
                }
                    
                else if(action.equals("duplicate"))
                {
                    message.set_timestamp(clock.getTimeStamp());
                    
                    if (this.clock_type.equals("Logical"))
                      clock.tick();
                    else if (this.clock_type.equals("Vector"))
                      clock.tick(this.our_process_number);
                  
                    //System.out.println("Message duplicated!");
                    TimeStampedMessage duplicate_message = new TimeStampedMessage(message.destination,
                            message.kind,message.data);
                    duplicate_message.set_source(src);
                    duplicate_message.set_seqNum(seqNum);
                    duplicate_message.set_duplicate(true);
                    duplicate_message.set_timestamp(clock.getTimeStamp());
                    
                    if (this.clock_type.equals("Logical"))
                      clock.tick();
                    else if (this.clock_type.equals("Vector"))
                      clock.tick(this.our_process_number);
                    
                    oos = new ObjectOutputStream(s.getOutputStream());
                    oos.writeObject(message);
                    oos = new ObjectOutputStream(s.getOutputStream());
                    oos.writeObject(duplicate_message);
                    //System.out.println("2 Objects written");
                    while(!delayed_send_queue.isEmpty())
                    {
                        String IP_now;
                        int port_now;
                        TimeStampedMessage delayed = delayed_send_queue.pop();
                        s = sendingMap.get(delayed.destination);
                        
                        delayed.set_timestamp(clock.getTimeStamp());
                        
                        if (this.clock_type.equals("Logical"))
                          clock.tick();
                        else if (this.clock_type.equals("Vector"))
                          clock.tick(this.our_process_number);
                        
                        oos = new ObjectOutputStream(s.getOutputStream());
                        oos.writeObject(delayed);
                        //System.out.println("1 Delayed message written");
                    }
                }
                    
                else if(action.equals("send"))
                {
                    //System.out.println("Message sent!");
                    message.set_timestamp(clock.getTimeStamp());
                    
                    if (this.clock_type.equals("Logical"))
                      clock.tick();
                    else if (this.clock_type.equals("Vector"))
                      clock.tick(this.our_process_number);
                  
                    oos=new ObjectOutputStream(s.getOutputStream());
                    oos.writeObject(message);
                    //System.out.println("Object written");
                    while(!delayed_send_queue.isEmpty())
                    {
                        String IP_now;
                        int port_now;
                        TimeStampedMessage delayed = delayed_send_queue.pop();
                        s = sendingMap.get(delayed.destination);
                        
                        delayed.set_timestamp(clock.getTimeStamp());
                        
                        if (this.clock_type.equals("Logical"))
                          clock.tick();
                        else if (this.clock_type.equals("Vector"))
                          clock.tick(this.our_process_number);
                        
                        oos = new ObjectOutputStream(s.getOutputStream());
                        oos.writeObject(delayed);
                        //System.out.println("1 Delayed message written");
                    }
                }
                    
                else
                {
                    System.out.println("Invalid action specified! "
                            + "Cannot handle message");
                    return;
                }
            }
            catch(Exception e)
            {
                System.out.println("Exception in parsing action:" + e);
            }    
        }
        catch(Exception e)
        {
            System.out.println("Excdeption in sending:" + e);
        }
    }
    TimeStampedMessage receive( )
    {
        TimeStampedMessage message;
        synchronized(lock)
        {
            if(received_queue.isEmpty())
            {
                message=new TimeStampedMessage("NULL","NULL","NULL");
            }
            else
            {
                message = received_queue.pop();
            }
        }
        
        return message;
    }
    
}
  
class Socket_Listener implements Runnable
{
    int port_number;
    MessagePasser mp1;
    public Socket_Listener(int port_no, MessagePasser mp1)
    {
        this.port_number = port_no;
        this.mp1 = mp1;
    }
    public void run()
    {
        try 
        {
            ServerSocket ss = new ServerSocket(port_number);
            while(true)
            {
                    Socket s=ss.accept();
                    //System.out.println("Thread about to be created");
                    OurRunnable or = new OurRunnable(s,this.mp1);
                    Thread worker = new Thread(or);
                    worker.start();
            }
        }
        catch(Exception e)
        {
            
        }
    }
}

class OurRunnable implements Runnable
{
    Socket s;
    MessagePasser mp1;
    LinkedList<TimeStampedMessage> delayed_received_queue;
    LinkedList<TimeStampedMessage> received_queue;
    public OurRunnable(Socket ss,MessagePasser mp1)
    {
        s=ss;
        this.mp1=mp1;
    }
    public void run()
    {
        ObjectInputStream ois;
        try
        {
            while(true)
            {
                ois = new ObjectInputStream(s.getInputStream());
                TimeStampedMessage message = (TimeStampedMessage)ois.readObject();
                //System.out.println(message.data);
                String action="receive";
                String src = message.source;
                String kind = message.kind;
                String dest = message.destination;
                int seqNum = message.seqNum;
                /* check the rules for sending/recving */
                for (Map<String, Object> rule:mp1.recvRules) 
                {         
                    if(rule.containsKey("src") && !rule.get("src").equals(src)||
                    rule.containsKey("kind") && !rule.get("kind").equals(kind)||
                    rule.containsKey("dest") && !rule.get("dest").equals(dest)||
                    rule.containsKey("seqNum") &&
                            !rule.get("seqNum").equals(seqNum) ||
                    rule.containsKey("duplicate") && 
                            !rule.get("duplicate").equals(message.duplicate))
                        continue;
                                
                    action = (String) rule.get("action");
                    break;
                }
                //System.out.println("Action is:"+action);
                try
                {
                    if(action.equals("drop"))
                    {
                        //System.out.println("Received message dropped!");
                    }

                    else if(action.equals("delay"))
                    {
                        //System.out.println("Received message delayed!");
                        synchronized(mp1.lock)
                        {
                            mp1.delayed_received_queue.addLast(message);
                        }
                    }

                    else if(action.equals("duplicate"))
                    {
                        //System.out.println("Received message duplicated!");
                        System.out.println("Clock now:" + mp1.clock.getTimeStamp().get_timestamp());
                        
                        TimeStampedMessage duplicate_message = 
                                new TimeStampedMessage(message.destination,
                                        message.kind,message.data);
                        duplicate_message.set_source(message.source);
                        duplicate_message.set_seqNum(message.seqNum);
                        duplicate_message.set_duplicate(true);
                        
                        synchronized(mp1.lock)
                        {
                            if(mp1.clock_type.equals("Logical"))
                            {
                                mp1.clock.update(message.get_timestamp());
                            }
                            else if(mp1.clock_type.equals("Vector"))
                            {
                                mp1.clock.update(message.get_timestamp(), mp1.our_process_number);
                            }
                            System.out.println("Clock now:" + mp1.clock.getTimeStamp().get_timestamp());
                            mp1.received_queue.addLast(message);
                            duplicate_message.set_timestamp(message.get_timestamp());
                    
                            if (mp1.clock_type.equals("Logical"))
                              mp1.clock.tick();
                            else if (mp1.clock_type.equals("Vector"))
                              mp1.clock.tick(mp1.our_process_number);
                            System.out.println("Clock now:" + mp1.clock.getTimeStamp().get_timestamp());
                            mp1.received_queue.addLast(duplicate_message);
                            while(!mp1.delayed_received_queue.isEmpty())
                            {
                                //System.out.println("One delayed messaged received");
                                TimeStampedMessage m = mp1.delayed_received_queue.pop();
                                if(mp1.clock_type.equals("Logical"))
                                {
                                    mp1.clock.update(m.get_timestamp());
                                }
                                else if(mp1.clock_type.equals("Vector"))
                                {
                                    mp1.clock.update(m.get_timestamp(), mp1.our_process_number);
                                }
                                mp1.received_queue.addLast(m);
                            }
                        }
                    }

                    else if(action.equals("receive"))
                    {
                        synchronized(mp1.lock)
                        {
                            if(mp1.clock_type.equals("Logical"))
                            {
                                mp1.clock.update(message.get_timestamp());
                            }
                            else if(mp1.clock_type.equals("Vector"))
                            {
                                mp1.clock.update(message.get_timestamp(), mp1.our_process_number);
                            }
                            mp1.received_queue.addLast(message);
                            while(!mp1.delayed_received_queue.isEmpty())
                            {
                                TimeStampedMessage m = mp1.delayed_received_queue.pop();
                                if(mp1.clock_type.equals("Logical"))
                                {
                                    mp1.clock.update(m.get_timestamp());
                                }
                                else if(mp1.clock_type.equals("Vector"))
                                {
                                    mp1.clock.update(m.get_timestamp(), mp1.our_process_number);
                                }
                                mp1.received_queue.addLast(m);
                            }
                        }
                    }
                    else
                    {
                        System.out.println("Invalid action specified! "
                                + "Cannot handle message");
                    }
                }
                catch(Exception e)
                {
                    System.out.println("The receiver has terminated!" + e);
                }
            }
        } 
        catch (Exception ex) 
        {
            System.out.println("The other user has terminated!" + ex);
            //System.exit(1);
        }
    }
}
